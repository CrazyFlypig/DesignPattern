# 单例模式 Singleton
## 定义
* 确保一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。常被用来管理共享资源。
## 类型
* 创建类模式
## 类图
![单例模式类图](http://i.imgur.com/7RqSQu3.jpg)
## 类特点
1. 使用私有静态变量记录Singleton类的唯一实例。
1. 私有构造方法
3. 以自己实例为返回值的静态的共有方法
## 实现

1. 饿汉式
	* JVM在加载类时马上创建实例。
	* 在静态初始化器中创建实例，保证线程安全。
	* 缺点：若实例在创建和运行时负担繁重，会降低程序性能
2. 同步懒汉式
	* 在需要时创建对象。
	* 缺点：多次无用同步锁判断降低性能。
3. “双重检查加锁”懒汉式
	* 在对象实例化成功后，不需要判断锁，不会因为同步而降低性能。
## 单例模式应用
### 单例模式的优点：
* 在内存中只存在一个对象，满足特定需求
* 可以全局访问
* 避免对资源的多重占用
* 避免频繁的创建销毁对象，可以提高性能。
### 适用场景
* 需要频繁实例化然后销毁的对象。
* 创建对象时耗时过长或占用资源过多，但又经常用到的对象。
* 有状态的工具类对象。
* 频繁访问数据库或文件的对象。
* 只要求一个对象的场景。如：线程池对象、日志对象、处理偏好设置和注册表的对象。
### 注意事项
* 使用反射会破化单例模式的机制
* 不要做断开单例类对象与类中静态引用的危险操作
* 多线程使用单例共享资源时，注意线程安全问题。
## 其它问题
1. 单例对象长时间不用会被jvm垃圾收集器收集吗？
	* 在hotspot虚拟机中，除非人为地断开静态引用对单例对象的连接，否则jvm垃圾收集器不会回收单例对象。
2. 在一个jvm中会出现多个单例吗?
	* 在分布式系统、多个类加载器和序列化的情况下，会产生多个单例对象。
	* 在多个类加载器中使用单例模式，需自行指定类加载器，并指定同一个类加载器。
	* 在同一个jvm中，使用getInstance()方法只能得到同一个单例。
	* 除非使用反射方式，将会得到多个单例对象。
3. 懒汉式单例线程安全吗？
	* 使用synchronized关键字修饰后，性能降低，但线程安全。
4. 单例模式可以被继承吗？
	* 由于单例的构造方法是private修饰的，所以不可被继承。
	* 想让子类正常工作，基类必须实现注册表（Registry）功能。但开发意义不大。
5. 单例是饿汉好，还是懒汉好？
	* java中，饿汉优于懒汉，C++中一般使用懒汉式。
6. 全局变量引用对象与单例模式差别？
	1. 二者都可保证在全局使用一个实例。
	2. 全局变量不能保证实例的唯一性。
	3. 使用全局变量也会鼓励开发人员，用许多全局变量指向小对象来造成命名空间（namespace）的污染。